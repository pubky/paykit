const { Payment, PAYMENT_STATE } = require('./Payment')
/**
 * @class PaymentOrder - This class is used to create a payments
 *
 */

class PaymentOrder {
  static generateId () {
    return 'totally-random-order-id'
  }

  // TODO: add validators

  constructor (orderParams, db) {
    this.orderParams = orderParams
    this.db = db

    this.id = null
    this.state = ORDER_STATE.CREATED

    this.clientOrderId = orderParams.clientOrderId
    this.type = orderParams.type || ORDER_TYPE.ONE_TIME
    if (this.type === ORDER_TYPE.ONE_TIME) {
      this.frequency = null
    } else {
      this.frequency = orderParams.frequency
    }

    this.payments = []

    this.amount = orderParams.amount
    this.currency = orderParams.currency || 'BTC'
    this.denomination = orderParams.denomination || 'BASE'
    this.targetURL = orderParams.targetURL
    this.memo = orderParams.memo || ''
    this.sendingPriority = orderParams.sendingPriority

    if (this.type === ORDER_TYPE.RECCURING) {
      throw new Error(ERROR.NOT_IMPLEMENTED)
    }
  }

  async init () {
    this.id = PaymentOrder.generateId()
    // TODO: check if order with this.clientOrderId already exists
    this.state = ORDER_STATE.INITIALIZED
    if (this.orderParams.type === ORDER_TYPE.RECCURING) {
      await this.createReccuringOrder()
    } else {
      await this.createOneTimeOrder()
    }
  }

  async createOneTimeOrder () {
    const payment = new Payment(
      { ...this.orderParams, orderId: this.id },
      this.db
    )
    await payment.init()

    this.payments.push(payment)

    // TODO: save order and payment to db in a single transaction
    // this.save()
  }

  async createReccuringOrder () {
    // TODO: save order and payments to db in a single transaction
    throw new Error(ERROR.NOT_IMPLEMENTED)
  }

  /**
   * @method process - Process order
   * @returns {Promise<Payment>}
   */
  async process () {
    if (this.state === ORDER_STATE.INITIALIZED) {
      // TODO: db transaction
      // first run
      this.state = ORDER_STATE.PROCESSING
      await this.update()
      return this.payments[0].process()
    } else if (this.state === ORDER_STATE.PROCESSING) {
      if (this.payments[0].pluginState === 'failed') {
        return this.payments[0].process()
      } else {
        throw new Error(ERROR.NOT_IMPLEMENTED)
      }
      // TODO: check if there are any payments in progress
      // if there are, then do nothing
      // if there are none, then check if there are any payments that are not yet in progress
      // if there are, then start executing first related payment if its executeAt < Date.now()
    } else {
      throw new Error(ERROR.CAN_NOT_PROCESS_ORDER)
    }
  }

  async complete () {
    if (this.state === ORDER_STATE.CANCELLED) {
      throw new Error(ERROR.ORDER_CANCELLED)
    }

    if (this.payments.every((payment) => payment.state === PAYMENT_STATE.COMPLETED)) {
      this.state = ORDER_STATE.COMPLETED
      await this.update()
    } else {
      throw new Error(ERROR.OUTSTANDING_PAYMENTS)
    }
  }

  async cancel () {
    if (this.state === ORDER_STATE.COMPLETED) {
      throw new Error(ERROR.ORDER_COMPLETED)
    }

    // TODO: db transaction
    this.payments
      .filter((payment) => payment.state !== PAYMENT_STATE.COMPLETED)
      .forEach(async (payment) => {
        await payment.cancel()
      })

    this.state = ORDER_STATE.CANCELLED
    await this.update()
  }

  serialize () {
    return {
      id: this.id,
      clientOrderId: this.clientOrderId,
      type: this.type,
      state: this.state,
      frequency: this.frequency,

      amount: this.amount,
      currency: this.currency,
      denomination: this.denomination,
      targetURL: this.targetURL,
      memo: this.memo,
      sendingPriority: this.sendingPriority
    }
  }

  async save () {
    // XXX: here id will be generated by init() method
    //
    // TODO: needs to be more sophisticated than this
    // check if payment already exists as well
    // save corresponding payments
    //    if (this.id) {
    //      const order = await this.db.get(this.id, { removed: '*' })
    //      if (order) throw new Error(ERROR.ALREADY_EXISTS(this.id))
    //      // something very fishy is going on
    //    }
    //
    //    this.id = PaymentOrder.generateId()
    const orderObject = this.serialize()
    // Order.validateOrderObject(orderObject)

    // TODO: db transaction
    await this.db.save(orderObject)
    await Promise.all(this.payments.map(async (payment) => {
      await payment.save()
    }))
  }

  async update () {
    // TODO: add some validation
    // also check for state and existing payments associated with this order
    const serialized = this.serialize()
    // Payment.validatePaymentObject(serialized)
    await this.db.update(this.id, serialized)
  }

  static async find (id, db) {
    const orderParams = await db.get(id)
    const paymentOrder = new PaymentOrder(orderParams, db)
    await paymentOrder.init()

    return paymentOrder
  }
}

const ERROR = {
  NOT_IMPLEMENTED: 'Not implemented',
  ORDER_PARAMS_REQUIRED: 'Order params are required',
  ORDER_AMOUNT_REQUIRED: 'Order amount is required',
  ORDER_TARGET_URL_REQUIRED: 'Order target url is required',
  ORDER_CLIENT_ORDER_ID_REQUIRED: 'Order client order id is required',
  ORDER_CONFIG_REQUIRED: 'Order config is required',
  ORDER_CONFIG_SENDING_PARTY_REQUIRED: 'Order config sending party is required',
  DB_REQUIRED: 'DB is required',
  DB_NOT_READY: 'DB is not ready',
  OUTSTANDING_PAYMENTS: 'There are outstanding payments',
  ORDER_CANCELLED: 'Order is cancelled',
  ORDER_COMPLETED: 'Order is completed',
  CAN_NOT_PROCESS_ORDER: 'Can not process order'
}

const ORDER_TYPE = {
  ONE_TIME: 'one-time',
  RECCURING: 'reccuring'
}

const ORDER_STATE = {
  CREATED: 'created',
  INITIALIZED: 'initialized',
  PROCESSING: 'processing',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled'
}

module.exports = { PaymentOrder, ORDER_TYPE, ORDER_STATE, ERROR }
